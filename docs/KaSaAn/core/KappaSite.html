<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>KaSaAn.core.KappaSite API documentation</title>
<meta name="description" content="Contains `KappaPort` and `KappaCounter`; classes for representing the components of an agent signature." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>KaSaAn.core.KappaSite</code></h1>
</header>
<section id="section-intro">
<p>Contains <code><a title="KaSaAn.core.KappaSite.KappaPort" href="#KaSaAn.core.KappaSite.KappaPort">KappaPort</a></code> and <code><a title="KaSaAn.core.KappaSite.KappaCounter" href="#KaSaAn.core.KappaSite.KappaCounter">KappaCounter</a></code>; classes for representing the components of an agent signature.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
&#34;&#34;&#34;Contains `KappaPort` and `KappaCounter`; classes for representing the components of an agent signature.&#34;&#34;&#34;

import re

from .KappaEntity import KappaEntity
from .KappaError import PortParseError, CounterParseError, PortSatisfactionError


class KappaPort(KappaEntity):
    &#34;&#34;&#34;
Class for representing traditional Kappa Sites, e.g. `s[3]`, `g[.]{b}`, or `k[_]{#}`.

What is an embedding?
---------------------

The statement &#39;A contains B&#39;, or &#39;A in B&#39;, we interpret as meaning &#39;A embeds in B&#39;, specifically &#39;A satisfied by B&#39;,
akin to saying &#39;B matches A&#39;, where &#39;match&#39; is the inverse mapping to &#39;embed&#39;. See `KappaPort.embeds_in` and
`KappaPort.matches_to`
Besides typing (e.g. can&#39;t satisfy `KappaPort` with a `KappaCounter`), this satisfaction requires three true components,
the name, the internal state, and the bond state.

Site names are only satisfied by equality of their string representation.

Internal state truth table
--------------------------

* `s{#} in s{#}` &lt;= True
* `s{a} in s{#}` &lt;= False
* `s{#} in s{a}` &lt;= True
* `s{a} in s{a}` &lt;= True
* `s{a} in s{b}` &lt;= False

Bond state truth table
----------------------

* `s[#] in [#]` &lt;= True
* `s[_] in [#]` &lt;= False
* `s[.] in [#]` &lt;= False
* `s[8] in [#]` &lt;= False
* `s[#] in [_]` &lt;= True
* `s[_] in [_]` &lt;= True
* `s[.] in [_]` &lt;= False
* `s[7] in [_]` &lt;= True
* `s[#] in [.]` &lt;= True
* `s[_] in [.]` &lt;= False
* `s[.] in [.]` &lt;= True
* `s[6] in [.]` &lt;= False
* `s[#] in [5]` &lt;= True
* `s[_] in [5]` &lt;= True
* `s[.] in [5]` &lt;= False
* `s[5] in [5]` &lt;= True
* `s[3] in [4]` &lt;= False
    &#34;&#34;&#34;

    # define patterns that make up a port
    __ident = r&#39;[_~][a-zA-Z0-9_~+-]+|[a-zA-Z][a-zA-Z0-9_~+-]*&#39;
    __port_name_pat = r&#39;(&#39; + __ident + r&#39;)&#39;
    __int_state_pat = r&#39;(?:{(&#39; + __ident + r&#39;|#)(?:(/)(&#39; + __ident + r&#39;))?})?&#39;
    __bnd_state_pat = r&#39;\[(.|_|#|\d+)(?:(/)(.|\d+))?\]&#39;
    __port_pat = r&#39;^&#39; + __port_name_pat + __int_state_pat + __bnd_state_pat + __int_state_pat + r&#39;$&#39;
    __port_pat_re = re.compile(__port_pat)

    def __init__(self, expression: str):
        self._raw_expression: str
        self._port_name: str
        self._present_bond_state: str
        self._bond_operand: str
        self._future_bond_state: str
        self._present_int_state: str
        self._int_operand: str
        self._future_int_state: str
        self._kappa_expression: str
        self._bond_operation: str

        self._raw_expression = expression
        # Remove line breaks, tabs, multi-spaces
        expression = self._whitespace_re.sub(&#39;&#39;, expression)
        # parse assuming full site declaration, with bond state declared
        g = self.__port_pat_re.match(expression.strip())
        # if that fails, try parsing with bond state explicitly declared as a wildcard
        if not g:
            g = self.__port_pat_re.match(expression.strip() + &#39;[#]&#39;)
        # if that fails, throw an error
        if not g:
            raise PortParseError(&#39;Invalid port declaration &lt;&#39; + expression + &#39;&gt;&#39;)
        # assuming it parsed, assign capturing groups to variables
        self._port_name = g.group(1)
        # figure out what type of bond operation is being performed
        self._present_bond_state = g.group(5)
        if g.group(6):                                                  # if there&#39;s an operation
            self._bond_operand = &#39;/&#39;
            self._future_bond_state = g.group(6)
            self._future_bond_state = g.group(7)
            if g.group(5) == &#39;.&#39;:
                if g.group(7) != &#39;.&#39;:                                   # ./X
                    self._bond_operation = &#39;creation&#39;
                else:                                                   # ./.
                    self._bond_operation = &#39;&#39;
            elif g.group(5) == &#39;_&#39;:
                if g.group(7) == &#39;.&#39;:                                   # _/.
                    self._bond_operation = &#39;deletion&#39;
                else:                                                   # _/X
                    self._bond_operation = &#39;unknown&#39;
            elif g.group(5) == &#39;#&#39;:                                     # #/?
                self._bond_operation = &#39;unknown&#39;
            else:
                if g.group(7) == &#39;.&#39;:                                   # X/.
                    self._bond_operation = &#39;deletion&#39;
                else:                                                   # X/Y
                    self._bond_operation = &#39;swap&#39;
        else:                                                           # if there&#39;s no operation
            self._bond_operand = &#39;&#39;
            self._future_bond_state = &#39;&#39;
            self._bond_operation = &#39;&#39;
        # figure out what type of internal state operation is being performed
        if g.group(2):
            self._present_int_state = g.group(2)
            self._int_operand = g.group(3) if g.group(3) else &#39;&#39;
            self._future_int_state = g.group(4) if g.group(4) else &#39;&#39;
        elif g.group(8):
            self._present_int_state = g.group(8)
            self._int_operand = g.group(9) if g.group(9) else &#39;&#39;
            self._future_int_state = g.group(10) if g.group(10) else &#39;&#39;
        else:                                                          # unless specified, will default to wildcard &#39;#&#39;
            self._present_int_state = &#39;#&#39;
            self._int_operand = &#39;&#39;
            self._future_int_state = &#39;&#39;
        # canonicalize the kappa expression
        self._kappa_expression = \
            self._port_name + \
            &#39;[&#39; + self._present_bond_state + self._bond_operand + self._future_bond_state + &#39;]&#39; + \
            &#39;{&#39; + self._present_int_state + self._int_operand + self._future_int_state + &#39;}&#39;

    def __contains__(self, query) -&gt; bool:
        &#34;&#34;&#34;&#34;&#34;&#34;

        # we can&#39;t satisfy ports with counters
        if type(query) is KappaCounter:
            raise PortParseError(&#39;Can not check for containment of supplied counter &lt;&#39; + query +
                                 &#39;&gt; in port &lt;&#39; + self._kappa_expression + &#39;&gt;&#39;)
        # make it a KappaPort if it&#39;s not one already
        elif not type(query) is KappaPort:
            query = KappaPort(query)
        # check if item is satisfied by self, Kappa-wise
        if self._int_operand or self._bond_operand:                     # if self has an operation, issue warning
            raise PortSatisfactionError(&#39;Undefined satisfaction test: &lt;&#39; + str(self) + &#39;&gt; has an operation in it.&#39;)
        elif query._int_operand or query._bond_operand:                 # if item has an operation, issue warning
            raise PortSatisfactionError(&#39;Undefined satisfaction test: &lt;&#39; + str(query) + &#39;&gt; has an operation in it.&#39;)
        else:
            satisfied = False
            # site name satisfied?
            if self._port_name == query._port_name:
                # first check if internal state satisfied,
                # then check if bond state satisfied
                if query._present_int_state == &#39;#&#39;:
                    satisfied = _bond_state_satisfaction(query_port=query, target_port=self)
                elif query._present_int_state == self._present_int_state:
                    satisfied = _bond_state_satisfaction(query_port=query, target_port=self)
        return satisfied

    def get_port_name(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the port&#39;s name.&#34;&#34;&#34;
        return self._port_name

    def get_port_int_state(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the port&#39;s internal state.&#34;&#34;&#34;
        return self._present_int_state + self._int_operand + self._future_int_state

    def get_port_bond_state(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the port&#39;s bond state.&#34;&#34;&#34;
        return self._present_bond_state + self._bond_operand + self._future_bond_state

    def get_port_current_bond(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the bond state or identifier required for the rule to fire, or the state or identifier
        used in the non-rule expression.&#34;&#34;&#34;
        return self._present_bond_state

    def get_port_future_bond(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the bond state or identifier after rule application, with an empty string for non-rule
        patterns or usages.&#34;&#34;&#34;
        return self._future_bond_state

    def get_port_current_state(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the internal state required for the rule to fire, or the state or identifier
        used in the non-rule expression.&#34;&#34;&#34;
        return self._present_int_state

    def get_port_future_state(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the internal state after rule application, with an empty string for non-rule
        patterns or usages.&#34;&#34;&#34;
        return self._future_int_state

    def get_port_bond_operation(self) -&gt; str:
        &#34;&#34;&#34;Returns the operation being performed on this port&#39;s bond: `creation`, `deletion`, `swap`, `unknown`, or
         an empty string for none.&#34;&#34;&#34;
        return self._bond_operation

    def has_bond_operation(self) -&gt; bool:
        &#34;&#34;&#34;Returns `true` if the port has an operation being performed on its bond state.&#34;&#34;&#34;
        return True if self._bond_operand else False

    def has_state_operation(self) -&gt; bool:
        &#34;&#34;&#34;Returns `true` if the port has an operation being performed on its internal state.&#34;&#34;&#34;
        return True if self._int_operand else False

    def embeds_in(self, target) -&gt; bool:
        &#34;&#34;&#34;Does the self entity embed in, is satisfied by, the target entity? The inverse mapping of an embedding is the
        matching, see `KappaPort.matches_to`.&#34;&#34;&#34;
        return self in target

    def matches_to(self, query) -&gt; bool:
        &#34;&#34;&#34;Does the self entity match to the query entity, does it satisfy it&#39;s requirements?  The inverse mapping of a
        matching is the embedding, see `KappaPort.embeds_in`.&#34;&#34;&#34;
        return query in self


class KappaCounter(KappaEntity):
    &#34;&#34;&#34;Class for representing counters, pseudo-Kappa sites, e.g. `c{=5}`.&#34;&#34;&#34;

    # define patterns that make up a counter
    __site_name_pat = r&#39;([_~][a-zA-Z0-9_~+-]+|[a-zA-Z][a-zA-Z0-9_~+-]*)&#39;
    __cnt_state_pat = r&#39;{(&gt;?=\d+)(?:(/)([+-]=\d+))?}&#39;
    __counter_pat = r&#39;^&#39; + __site_name_pat + __cnt_state_pat + r&#39;$&#39;
    __counter_pat_re = re.compile(__counter_pat)

    def __init__(self, expression: str):
        self._raw_expression: str
        self._counter_name: str
        self._current_state: str
        self._counter_operand: str
        self._counter_delta: str
        self._kappa_expression: str

        self._raw_expression = expression
        expression = self._whitespace_re.sub(&#39;&#39;, expression)     # Remove line breaks, tabs, multi-spaces
        # parse the counter
        g = self.__counter_pat_re.match(expression.strip())
        if not g:
            raise CounterParseError(&#39;Invalid counter declaration &lt;&#39; + expression + &#39;&gt;&#39;)
        # assign capturing groups to variables
        self._counter_name = g.group(1)
        self._current_state = g.group(2)
        self._counter_operand = g.group(3) if g.group(3) else &#39;&#39;
        self._counter_delta = g.group(4) if g.group(4) else &#39;&#39;
        # canonicalize the kappa expression
        self._kappa_expression = \
            self._counter_name + \
            &#39;{&#39; + self._current_state + self._counter_operand + self._counter_delta + &#39;}&#39;

    def get_counter_name(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the counter&#39;s name.&#34;&#34;&#34;
        return self._counter_name

    def get_counter_state(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the counter&#39;s value expression, including the delta if specified.&#34;&#34;&#34;
        return self._current_state + self._counter_operand + self._counter_delta

    def get_counter_tested_value(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the value being tested for the rule&#39;s application.&#34;&#34;&#34;
        return self._current_state

    def get_counter_delta(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the delta being applied to the counter&#39;s value.&#34;&#34;&#34;
        return self._counter_delta

    def has_operation(self) -&gt; bool:
        &#34;&#34;&#34;Returns true if this counter has an operation being performed on it.&#34;&#34;&#34;
        return True if self._counter_operand else False


def _bond_state_satisfaction(query_port: KappaPort, target_port: KappaPort) -&gt; bool:
    &#34;&#34;&#34;Is the query string satisfied by the target string, when read as bond states?&#34;&#34;&#34;
    if query_port.get_port_current_bond() == &#39;.&#39;:
        satisfied = True if target_port.get_port_current_bond() == &#39;.&#39; else False
    elif query_port.get_port_current_bond() == &#39;_&#39;:
        satisfied = True if target_port.get_port_current_bond() not in [&#39;.&#39;, &#39;#&#39;] else False
    elif query_port.get_port_current_bond() == &#39;#&#39;:
        satisfied = True
    else:
        satisfied = True if target_port.get_port_current_bond() == query_port.get_port_current_bond() else False
    return satisfied</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="KaSaAn.core.KappaSite.KappaCounter"><code class="flex name class">
<span>class <span class="ident">KappaCounter</span></span>
<span>(</span><span>expression: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for representing counters, pseudo-Kappa sites, e.g. <code>c{=5}</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KappaCounter(KappaEntity):
    &#34;&#34;&#34;Class for representing counters, pseudo-Kappa sites, e.g. `c{=5}`.&#34;&#34;&#34;

    # define patterns that make up a counter
    __site_name_pat = r&#39;([_~][a-zA-Z0-9_~+-]+|[a-zA-Z][a-zA-Z0-9_~+-]*)&#39;
    __cnt_state_pat = r&#39;{(&gt;?=\d+)(?:(/)([+-]=\d+))?}&#39;
    __counter_pat = r&#39;^&#39; + __site_name_pat + __cnt_state_pat + r&#39;$&#39;
    __counter_pat_re = re.compile(__counter_pat)

    def __init__(self, expression: str):
        self._raw_expression: str
        self._counter_name: str
        self._current_state: str
        self._counter_operand: str
        self._counter_delta: str
        self._kappa_expression: str

        self._raw_expression = expression
        expression = self._whitespace_re.sub(&#39;&#39;, expression)     # Remove line breaks, tabs, multi-spaces
        # parse the counter
        g = self.__counter_pat_re.match(expression.strip())
        if not g:
            raise CounterParseError(&#39;Invalid counter declaration &lt;&#39; + expression + &#39;&gt;&#39;)
        # assign capturing groups to variables
        self._counter_name = g.group(1)
        self._current_state = g.group(2)
        self._counter_operand = g.group(3) if g.group(3) else &#39;&#39;
        self._counter_delta = g.group(4) if g.group(4) else &#39;&#39;
        # canonicalize the kappa expression
        self._kappa_expression = \
            self._counter_name + \
            &#39;{&#39; + self._current_state + self._counter_operand + self._counter_delta + &#39;}&#39;

    def get_counter_name(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the counter&#39;s name.&#34;&#34;&#34;
        return self._counter_name

    def get_counter_state(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the counter&#39;s value expression, including the delta if specified.&#34;&#34;&#34;
        return self._current_state + self._counter_operand + self._counter_delta

    def get_counter_tested_value(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the value being tested for the rule&#39;s application.&#34;&#34;&#34;
        return self._current_state

    def get_counter_delta(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the delta being applied to the counter&#39;s value.&#34;&#34;&#34;
        return self._counter_delta

    def has_operation(self) -&gt; bool:
        &#34;&#34;&#34;Returns true if this counter has an operation being performed on it.&#34;&#34;&#34;
        return True if self._counter_operand else False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="KaSaAn.core.KappaEntity.KappaEntity" href="KappaEntity.html#KaSaAn.core.KappaEntity.KappaEntity">KappaEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="KaSaAn.core.KappaSite.KappaCounter.get_counter_delta"><code class="name flex">
<span>def <span class="ident">get_counter_delta</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string with the delta being applied to the counter's value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_counter_delta(self) -&gt; str:
    &#34;&#34;&#34;Returns a string with the delta being applied to the counter&#39;s value.&#34;&#34;&#34;
    return self._counter_delta</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaCounter.get_counter_name"><code class="name flex">
<span>def <span class="ident">get_counter_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string with the counter's name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_counter_name(self) -&gt; str:
    &#34;&#34;&#34;Returns a string with the counter&#39;s name.&#34;&#34;&#34;
    return self._counter_name</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaCounter.get_counter_state"><code class="name flex">
<span>def <span class="ident">get_counter_state</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string with the counter's value expression, including the delta if specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_counter_state(self) -&gt; str:
    &#34;&#34;&#34;Returns a string with the counter&#39;s value expression, including the delta if specified.&#34;&#34;&#34;
    return self._current_state + self._counter_operand + self._counter_delta</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaCounter.get_counter_tested_value"><code class="name flex">
<span>def <span class="ident">get_counter_tested_value</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string with the value being tested for the rule's application.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_counter_tested_value(self) -&gt; str:
    &#34;&#34;&#34;Returns a string with the value being tested for the rule&#39;s application.&#34;&#34;&#34;
    return self._current_state</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaCounter.has_operation"><code class="name flex">
<span>def <span class="ident">has_operation</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if this counter has an operation being performed on it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_operation(self) -&gt; bool:
    &#34;&#34;&#34;Returns true if this counter has an operation being performed on it.&#34;&#34;&#34;
    return True if self._counter_operand else False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaPort"><code class="flex name class">
<span>class <span class="ident">KappaPort</span></span>
<span>(</span><span>expression: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for representing traditional Kappa Sites, e.g. <code>s[3]</code>, <code>g[.]{b}</code>, or <code>k[_]{#}</code>.</p>
<h2 id="what-is-an-embedding">What is an embedding?</h2>
<p>The statement 'A contains B', or 'A in B', we interpret as meaning 'A embeds in B', specifically 'A satisfied by B',
akin to saying 'B matches A', where 'match' is the inverse mapping to 'embed'. See <code><a title="KaSaAn.core.KappaSite.KappaPort.embeds_in" href="#KaSaAn.core.KappaSite.KappaPort.embeds_in">KappaPort.embeds_in()</a></code> and
<code><a title="KaSaAn.core.KappaSite.KappaPort.matches_to" href="#KaSaAn.core.KappaSite.KappaPort.matches_to">KappaPort.matches_to()</a></code>
Besides typing (e.g. can't satisfy <code><a title="KaSaAn.core.KappaSite.KappaPort" href="#KaSaAn.core.KappaSite.KappaPort">KappaPort</a></code> with a <code><a title="KaSaAn.core.KappaSite.KappaCounter" href="#KaSaAn.core.KappaSite.KappaCounter">KappaCounter</a></code>), this satisfaction requires three true components,
the name, the internal state, and the bond state.</p>
<p>Site names are only satisfied by equality of their string representation.</p>
<h2 id="internal-state-truth-table">Internal State Truth Table</h2>
<ul>
<li><code>s{#} in s{#}</code> &lt;= True</li>
<li><code>s{a} in s{#}</code> &lt;= False</li>
<li><code>s{#} in s{a}</code> &lt;= True</li>
<li><code>s{a} in s{a}</code> &lt;= True</li>
<li><code>s{a} in s{b}</code> &lt;= False</li>
</ul>
<h2 id="bond-state-truth-table">Bond State Truth Table</h2>
<ul>
<li><code>s[#] in [#]</code> &lt;= True</li>
<li><code>s[_] in [#]</code> &lt;= False</li>
<li><code>s[.] in [#]</code> &lt;= False</li>
<li><code>s[8] in [#]</code> &lt;= False</li>
<li><code>s[#] in [_]</code> &lt;= True</li>
<li><code>s[_] in [_]</code> &lt;= True</li>
<li><code>s[.] in [_]</code> &lt;= False</li>
<li><code>s[7] in [_]</code> &lt;= True</li>
<li><code>s[#] in [.]</code> &lt;= True</li>
<li><code>s[_] in [.]</code> &lt;= False</li>
<li><code>s[.] in [.]</code> &lt;= True</li>
<li><code>s[6] in [.]</code> &lt;= False</li>
<li><code>s[#] in [5]</code> &lt;= True</li>
<li><code>s[_] in [5]</code> &lt;= True</li>
<li><code>s[.] in [5]</code> &lt;= False</li>
<li><code>s[5] in [5]</code> &lt;= True</li>
<li><code>s[3] in [4]</code> &lt;= False</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KappaPort(KappaEntity):
    &#34;&#34;&#34;
Class for representing traditional Kappa Sites, e.g. `s[3]`, `g[.]{b}`, or `k[_]{#}`.

What is an embedding?
---------------------

The statement &#39;A contains B&#39;, or &#39;A in B&#39;, we interpret as meaning &#39;A embeds in B&#39;, specifically &#39;A satisfied by B&#39;,
akin to saying &#39;B matches A&#39;, where &#39;match&#39; is the inverse mapping to &#39;embed&#39;. See `KappaPort.embeds_in` and
`KappaPort.matches_to`
Besides typing (e.g. can&#39;t satisfy `KappaPort` with a `KappaCounter`), this satisfaction requires three true components,
the name, the internal state, and the bond state.

Site names are only satisfied by equality of their string representation.

Internal state truth table
--------------------------

* `s{#} in s{#}` &lt;= True
* `s{a} in s{#}` &lt;= False
* `s{#} in s{a}` &lt;= True
* `s{a} in s{a}` &lt;= True
* `s{a} in s{b}` &lt;= False

Bond state truth table
----------------------

* `s[#] in [#]` &lt;= True
* `s[_] in [#]` &lt;= False
* `s[.] in [#]` &lt;= False
* `s[8] in [#]` &lt;= False
* `s[#] in [_]` &lt;= True
* `s[_] in [_]` &lt;= True
* `s[.] in [_]` &lt;= False
* `s[7] in [_]` &lt;= True
* `s[#] in [.]` &lt;= True
* `s[_] in [.]` &lt;= False
* `s[.] in [.]` &lt;= True
* `s[6] in [.]` &lt;= False
* `s[#] in [5]` &lt;= True
* `s[_] in [5]` &lt;= True
* `s[.] in [5]` &lt;= False
* `s[5] in [5]` &lt;= True
* `s[3] in [4]` &lt;= False
    &#34;&#34;&#34;

    # define patterns that make up a port
    __ident = r&#39;[_~][a-zA-Z0-9_~+-]+|[a-zA-Z][a-zA-Z0-9_~+-]*&#39;
    __port_name_pat = r&#39;(&#39; + __ident + r&#39;)&#39;
    __int_state_pat = r&#39;(?:{(&#39; + __ident + r&#39;|#)(?:(/)(&#39; + __ident + r&#39;))?})?&#39;
    __bnd_state_pat = r&#39;\[(.|_|#|\d+)(?:(/)(.|\d+))?\]&#39;
    __port_pat = r&#39;^&#39; + __port_name_pat + __int_state_pat + __bnd_state_pat + __int_state_pat + r&#39;$&#39;
    __port_pat_re = re.compile(__port_pat)

    def __init__(self, expression: str):
        self._raw_expression: str
        self._port_name: str
        self._present_bond_state: str
        self._bond_operand: str
        self._future_bond_state: str
        self._present_int_state: str
        self._int_operand: str
        self._future_int_state: str
        self._kappa_expression: str
        self._bond_operation: str

        self._raw_expression = expression
        # Remove line breaks, tabs, multi-spaces
        expression = self._whitespace_re.sub(&#39;&#39;, expression)
        # parse assuming full site declaration, with bond state declared
        g = self.__port_pat_re.match(expression.strip())
        # if that fails, try parsing with bond state explicitly declared as a wildcard
        if not g:
            g = self.__port_pat_re.match(expression.strip() + &#39;[#]&#39;)
        # if that fails, throw an error
        if not g:
            raise PortParseError(&#39;Invalid port declaration &lt;&#39; + expression + &#39;&gt;&#39;)
        # assuming it parsed, assign capturing groups to variables
        self._port_name = g.group(1)
        # figure out what type of bond operation is being performed
        self._present_bond_state = g.group(5)
        if g.group(6):                                                  # if there&#39;s an operation
            self._bond_operand = &#39;/&#39;
            self._future_bond_state = g.group(6)
            self._future_bond_state = g.group(7)
            if g.group(5) == &#39;.&#39;:
                if g.group(7) != &#39;.&#39;:                                   # ./X
                    self._bond_operation = &#39;creation&#39;
                else:                                                   # ./.
                    self._bond_operation = &#39;&#39;
            elif g.group(5) == &#39;_&#39;:
                if g.group(7) == &#39;.&#39;:                                   # _/.
                    self._bond_operation = &#39;deletion&#39;
                else:                                                   # _/X
                    self._bond_operation = &#39;unknown&#39;
            elif g.group(5) == &#39;#&#39;:                                     # #/?
                self._bond_operation = &#39;unknown&#39;
            else:
                if g.group(7) == &#39;.&#39;:                                   # X/.
                    self._bond_operation = &#39;deletion&#39;
                else:                                                   # X/Y
                    self._bond_operation = &#39;swap&#39;
        else:                                                           # if there&#39;s no operation
            self._bond_operand = &#39;&#39;
            self._future_bond_state = &#39;&#39;
            self._bond_operation = &#39;&#39;
        # figure out what type of internal state operation is being performed
        if g.group(2):
            self._present_int_state = g.group(2)
            self._int_operand = g.group(3) if g.group(3) else &#39;&#39;
            self._future_int_state = g.group(4) if g.group(4) else &#39;&#39;
        elif g.group(8):
            self._present_int_state = g.group(8)
            self._int_operand = g.group(9) if g.group(9) else &#39;&#39;
            self._future_int_state = g.group(10) if g.group(10) else &#39;&#39;
        else:                                                          # unless specified, will default to wildcard &#39;#&#39;
            self._present_int_state = &#39;#&#39;
            self._int_operand = &#39;&#39;
            self._future_int_state = &#39;&#39;
        # canonicalize the kappa expression
        self._kappa_expression = \
            self._port_name + \
            &#39;[&#39; + self._present_bond_state + self._bond_operand + self._future_bond_state + &#39;]&#39; + \
            &#39;{&#39; + self._present_int_state + self._int_operand + self._future_int_state + &#39;}&#39;

    def __contains__(self, query) -&gt; bool:
        &#34;&#34;&#34;&#34;&#34;&#34;

        # we can&#39;t satisfy ports with counters
        if type(query) is KappaCounter:
            raise PortParseError(&#39;Can not check for containment of supplied counter &lt;&#39; + query +
                                 &#39;&gt; in port &lt;&#39; + self._kappa_expression + &#39;&gt;&#39;)
        # make it a KappaPort if it&#39;s not one already
        elif not type(query) is KappaPort:
            query = KappaPort(query)
        # check if item is satisfied by self, Kappa-wise
        if self._int_operand or self._bond_operand:                     # if self has an operation, issue warning
            raise PortSatisfactionError(&#39;Undefined satisfaction test: &lt;&#39; + str(self) + &#39;&gt; has an operation in it.&#39;)
        elif query._int_operand or query._bond_operand:                 # if item has an operation, issue warning
            raise PortSatisfactionError(&#39;Undefined satisfaction test: &lt;&#39; + str(query) + &#39;&gt; has an operation in it.&#39;)
        else:
            satisfied = False
            # site name satisfied?
            if self._port_name == query._port_name:
                # first check if internal state satisfied,
                # then check if bond state satisfied
                if query._present_int_state == &#39;#&#39;:
                    satisfied = _bond_state_satisfaction(query_port=query, target_port=self)
                elif query._present_int_state == self._present_int_state:
                    satisfied = _bond_state_satisfaction(query_port=query, target_port=self)
        return satisfied

    def get_port_name(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the port&#39;s name.&#34;&#34;&#34;
        return self._port_name

    def get_port_int_state(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the port&#39;s internal state.&#34;&#34;&#34;
        return self._present_int_state + self._int_operand + self._future_int_state

    def get_port_bond_state(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the port&#39;s bond state.&#34;&#34;&#34;
        return self._present_bond_state + self._bond_operand + self._future_bond_state

    def get_port_current_bond(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the bond state or identifier required for the rule to fire, or the state or identifier
        used in the non-rule expression.&#34;&#34;&#34;
        return self._present_bond_state

    def get_port_future_bond(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the bond state or identifier after rule application, with an empty string for non-rule
        patterns or usages.&#34;&#34;&#34;
        return self._future_bond_state

    def get_port_current_state(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the internal state required for the rule to fire, or the state or identifier
        used in the non-rule expression.&#34;&#34;&#34;
        return self._present_int_state

    def get_port_future_state(self) -&gt; str:
        &#34;&#34;&#34;Returns a string with the internal state after rule application, with an empty string for non-rule
        patterns or usages.&#34;&#34;&#34;
        return self._future_int_state

    def get_port_bond_operation(self) -&gt; str:
        &#34;&#34;&#34;Returns the operation being performed on this port&#39;s bond: `creation`, `deletion`, `swap`, `unknown`, or
         an empty string for none.&#34;&#34;&#34;
        return self._bond_operation

    def has_bond_operation(self) -&gt; bool:
        &#34;&#34;&#34;Returns `true` if the port has an operation being performed on its bond state.&#34;&#34;&#34;
        return True if self._bond_operand else False

    def has_state_operation(self) -&gt; bool:
        &#34;&#34;&#34;Returns `true` if the port has an operation being performed on its internal state.&#34;&#34;&#34;
        return True if self._int_operand else False

    def embeds_in(self, target) -&gt; bool:
        &#34;&#34;&#34;Does the self entity embed in, is satisfied by, the target entity? The inverse mapping of an embedding is the
        matching, see `KappaPort.matches_to`.&#34;&#34;&#34;
        return self in target

    def matches_to(self, query) -&gt; bool:
        &#34;&#34;&#34;Does the self entity match to the query entity, does it satisfy it&#39;s requirements?  The inverse mapping of a
        matching is the embedding, see `KappaPort.embeds_in`.&#34;&#34;&#34;
        return query in self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="KaSaAn.core.KappaEntity.KappaEntity" href="KappaEntity.html#KaSaAn.core.KappaEntity.KappaEntity">KappaEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="KaSaAn.core.KappaSite.KappaPort.embeds_in"><code class="name flex">
<span>def <span class="ident">embeds_in</span></span>(<span>self, target) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Does the self entity embed in, is satisfied by, the target entity? The inverse mapping of an embedding is the
matching, see <code><a title="KaSaAn.core.KappaSite.KappaPort.matches_to" href="#KaSaAn.core.KappaSite.KappaPort.matches_to">KappaPort.matches_to()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def embeds_in(self, target) -&gt; bool:
    &#34;&#34;&#34;Does the self entity embed in, is satisfied by, the target entity? The inverse mapping of an embedding is the
    matching, see `KappaPort.matches_to`.&#34;&#34;&#34;
    return self in target</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaPort.get_port_bond_operation"><code class="name flex">
<span>def <span class="ident">get_port_bond_operation</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the operation being performed on this port's bond: <code>creation</code>, <code>deletion</code>, <code>swap</code>, <code>unknown</code>, or
an empty string for none.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_port_bond_operation(self) -&gt; str:
    &#34;&#34;&#34;Returns the operation being performed on this port&#39;s bond: `creation`, `deletion`, `swap`, `unknown`, or
     an empty string for none.&#34;&#34;&#34;
    return self._bond_operation</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaPort.get_port_bond_state"><code class="name flex">
<span>def <span class="ident">get_port_bond_state</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string with the port's bond state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_port_bond_state(self) -&gt; str:
    &#34;&#34;&#34;Returns a string with the port&#39;s bond state.&#34;&#34;&#34;
    return self._present_bond_state + self._bond_operand + self._future_bond_state</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaPort.get_port_current_bond"><code class="name flex">
<span>def <span class="ident">get_port_current_bond</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string with the bond state or identifier required for the rule to fire, or the state or identifier
used in the non-rule expression.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_port_current_bond(self) -&gt; str:
    &#34;&#34;&#34;Returns a string with the bond state or identifier required for the rule to fire, or the state or identifier
    used in the non-rule expression.&#34;&#34;&#34;
    return self._present_bond_state</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaPort.get_port_current_state"><code class="name flex">
<span>def <span class="ident">get_port_current_state</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string with the internal state required for the rule to fire, or the state or identifier
used in the non-rule expression.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_port_current_state(self) -&gt; str:
    &#34;&#34;&#34;Returns a string with the internal state required for the rule to fire, or the state or identifier
    used in the non-rule expression.&#34;&#34;&#34;
    return self._present_int_state</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaPort.get_port_future_bond"><code class="name flex">
<span>def <span class="ident">get_port_future_bond</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string with the bond state or identifier after rule application, with an empty string for non-rule
patterns or usages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_port_future_bond(self) -&gt; str:
    &#34;&#34;&#34;Returns a string with the bond state or identifier after rule application, with an empty string for non-rule
    patterns or usages.&#34;&#34;&#34;
    return self._future_bond_state</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaPort.get_port_future_state"><code class="name flex">
<span>def <span class="ident">get_port_future_state</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string with the internal state after rule application, with an empty string for non-rule
patterns or usages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_port_future_state(self) -&gt; str:
    &#34;&#34;&#34;Returns a string with the internal state after rule application, with an empty string for non-rule
    patterns or usages.&#34;&#34;&#34;
    return self._future_int_state</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaPort.get_port_int_state"><code class="name flex">
<span>def <span class="ident">get_port_int_state</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string with the port's internal state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_port_int_state(self) -&gt; str:
    &#34;&#34;&#34;Returns a string with the port&#39;s internal state.&#34;&#34;&#34;
    return self._present_int_state + self._int_operand + self._future_int_state</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaPort.get_port_name"><code class="name flex">
<span>def <span class="ident">get_port_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string with the port's name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_port_name(self) -&gt; str:
    &#34;&#34;&#34;Returns a string with the port&#39;s name.&#34;&#34;&#34;
    return self._port_name</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaPort.has_bond_operation"><code class="name flex">
<span>def <span class="ident">has_bond_operation</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>true</code> if the port has an operation being performed on its bond state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_bond_operation(self) -&gt; bool:
    &#34;&#34;&#34;Returns `true` if the port has an operation being performed on its bond state.&#34;&#34;&#34;
    return True if self._bond_operand else False</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaPort.has_state_operation"><code class="name flex">
<span>def <span class="ident">has_state_operation</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>true</code> if the port has an operation being performed on its internal state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_state_operation(self) -&gt; bool:
    &#34;&#34;&#34;Returns `true` if the port has an operation being performed on its internal state.&#34;&#34;&#34;
    return True if self._int_operand else False</code></pre>
</details>
</dd>
<dt id="KaSaAn.core.KappaSite.KappaPort.matches_to"><code class="name flex">
<span>def <span class="ident">matches_to</span></span>(<span>self, query) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Does the self entity match to the query entity, does it satisfy it's requirements?
The inverse mapping of a
matching is the embedding, see <code><a title="KaSaAn.core.KappaSite.KappaPort.embeds_in" href="#KaSaAn.core.KappaSite.KappaPort.embeds_in">KappaPort.embeds_in()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matches_to(self, query) -&gt; bool:
    &#34;&#34;&#34;Does the self entity match to the query entity, does it satisfy it&#39;s requirements?  The inverse mapping of a
    matching is the embedding, see `KappaPort.embeds_in`.&#34;&#34;&#34;
    return query in self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="KaSaAn.core" href="index.html">KaSaAn.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="KaSaAn.core.KappaSite.KappaCounter" href="#KaSaAn.core.KappaSite.KappaCounter">KappaCounter</a></code></h4>
<ul class="">
<li><code><a title="KaSaAn.core.KappaSite.KappaCounter.get_counter_delta" href="#KaSaAn.core.KappaSite.KappaCounter.get_counter_delta">get_counter_delta</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaCounter.get_counter_name" href="#KaSaAn.core.KappaSite.KappaCounter.get_counter_name">get_counter_name</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaCounter.get_counter_state" href="#KaSaAn.core.KappaSite.KappaCounter.get_counter_state">get_counter_state</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaCounter.get_counter_tested_value" href="#KaSaAn.core.KappaSite.KappaCounter.get_counter_tested_value">get_counter_tested_value</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaCounter.has_operation" href="#KaSaAn.core.KappaSite.KappaCounter.has_operation">has_operation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="KaSaAn.core.KappaSite.KappaPort" href="#KaSaAn.core.KappaSite.KappaPort">KappaPort</a></code></h4>
<ul class="">
<li><code><a title="KaSaAn.core.KappaSite.KappaPort.embeds_in" href="#KaSaAn.core.KappaSite.KappaPort.embeds_in">embeds_in</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaPort.get_port_bond_operation" href="#KaSaAn.core.KappaSite.KappaPort.get_port_bond_operation">get_port_bond_operation</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaPort.get_port_bond_state" href="#KaSaAn.core.KappaSite.KappaPort.get_port_bond_state">get_port_bond_state</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaPort.get_port_current_bond" href="#KaSaAn.core.KappaSite.KappaPort.get_port_current_bond">get_port_current_bond</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaPort.get_port_current_state" href="#KaSaAn.core.KappaSite.KappaPort.get_port_current_state">get_port_current_state</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaPort.get_port_future_bond" href="#KaSaAn.core.KappaSite.KappaPort.get_port_future_bond">get_port_future_bond</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaPort.get_port_future_state" href="#KaSaAn.core.KappaSite.KappaPort.get_port_future_state">get_port_future_state</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaPort.get_port_int_state" href="#KaSaAn.core.KappaSite.KappaPort.get_port_int_state">get_port_int_state</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaPort.get_port_name" href="#KaSaAn.core.KappaSite.KappaPort.get_port_name">get_port_name</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaPort.has_bond_operation" href="#KaSaAn.core.KappaSite.KappaPort.has_bond_operation">has_bond_operation</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaPort.has_state_operation" href="#KaSaAn.core.KappaSite.KappaPort.has_state_operation">has_state_operation</a></code></li>
<li><code><a title="KaSaAn.core.KappaSite.KappaPort.matches_to" href="#KaSaAn.core.KappaSite.KappaPort.matches_to">matches_to</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>