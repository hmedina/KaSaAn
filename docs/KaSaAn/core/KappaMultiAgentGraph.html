<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>KaSaAn.core.KappaMultiAgentGraph API documentation</title>
<meta name="description" content="Contains the parent class to `KappaSnapshot` and `KappaComplex`, with shared methods." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>KaSaAn.core.KappaMultiAgentGraph</code></h1>
</header>
<section id="section-intro">
<p>Contains the parent class to <code>KappaSnapshot</code> and <code>KappaComplex</code>, with shared methods.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#! /usr/bin/env python3
&#34;&#34;&#34;Contains the parent class to `KappaSnapshot` and `KappaComplex`, with shared methods.&#34;&#34;&#34;

from abc import abstractmethod
from typing import List, Dict, Optional
import matplotlib.colors as mpco
import networkx as nx
import xml.etree.ElementTree as ET

from .KappaAgent import KappaAgent
from .KappaBond import KappaBond
from .KappaEntity import KappaEntity


class KappaMultiAgentGraph(KappaEntity):
    &#34;&#34;&#34;Abstract class containing common components to `KappaComplex` and `KappaSnapshot`, its subclasses.&#34;&#34;&#34;

    @abstractmethod
    def __init__(self):
        pass

    @abstractmethod
    def to_networkx(self) -&gt; nx.MultiGraph:
        &#34;&#34;&#34;Abstract method included as place-holder for typing reasons.&#34;&#34;&#34;
        pass

    def _kappa_to_cytoscape_cx(self) -&gt; List[Dict]:
        &#34;&#34;&#34;
        Given a kappa graph (i.e. KappaComplex or KappaSnapshot), produce a Python structure
         that can be JSON encoded to produce a Cytoscape-compatible CX file.
        &#34;&#34;&#34;
        kappa_net = self.to_networkx()
        # construct &#34;node&#34; and &#34;nodeAttributes&#34; structures
        cx_nodes = []
        cx_node_attributes = []
        for node_ident, node_data in kappa_net.nodes.data():
            cx_node = {&#39;@id&#39;: node_ident,
                       &#39;n&#39;: node_data[&#39;kappa&#39;].get_agent_name()}
            cx_node_attribute = {&#39;po&#39;: node_ident,
                                 &#39;n&#39;: &#39;raw_expression&#39;,
                                 &#39;v&#39;: str(node_data[&#39;kappa&#39;])}
            cx_nodes.append(cx_node)
            cx_node_attributes.append(cx_node_attribute)
        # cytoscape expects edges to have identifiers; these exist in the same space as the nodes;
        # I preserve node identifiers, and start a counter from those to then identify edges
        edge_ident = 0 + kappa_net.number_of_nodes()
        cx_edges = []
        cx_edge_attributes = []
        for e_source, e_target, e_data in kappa_net.edges.data():
            # find the port names
            port_names = []
            e_source_kappa = kappa_net.nodes.data()[e_source][&#39;kappa&#39;]
            e_target_kappa = kappa_net.nodes.data()[e_target][&#39;kappa&#39;]
            bond_type: KappaBond = e_data[&#39;bond type&#39;]
            for this_agent in [e_source_kappa, e_target_kappa]:
                for this_site in this_agent.get_agent_signature():
                    # is this site a port, or a counter?
                    if this_site.get_port_bond_state():
                        if e_data[&#39;bond id&#39;] == this_site.get_port_bond_state():
                            port_names.append(this_site.get_port_name())
            # build edge dictionary list
            cx_edge = {&#39;s&#39;: e_source,
                       &#39;t&#39;: e_target,
                       &#39;@id&#39;: edge_ident}
            cx_edge_attribute = [{&#39;po&#39;: edge_ident,
                                  &#39;n&#39;: &#39;bond_type&#39;,
                                  &#39;v&#39;: str(bond_type)},
                                 {&#39;po&#39;: edge_ident,
                                  &#39;n&#39;: &#39;s_agent_type&#39;,
                                  &#39;v&#39;: e_source_kappa.get_agent_name()},
                                 {&#39;po&#39;: edge_ident,
                                  &#39;n&#39;: &#39;t_agent_type&#39;,
                                  &#39;v&#39;: e_target_kappa.get_agent_name()},
                                 {&#39;po&#39;: edge_ident,
                                  &#39;n&#39;: &#39;s_port_name&#39;,
                                  &#39;v&#39;: port_names[0]},
                                 {&#39;po&#39;: edge_ident,
                                  &#39;n&#39;: &#39;t_port_name&#39;,
                                  &#39;v&#39;: port_names[1]},
                                 {&#39;po&#39;: edge_ident,
                                  &#39;n&#39;: &#39;ident_in_snap&#39;,
                                  &#39;v&#39;: e_data[&#39;bond id&#39;]}]
            cx_edges.append(cx_edge)
            cx_edge_attributes.extend(cx_edge_attribute)
            edge_ident += 1
        # build cytoscape table structure
        cx_table_columns = [{&#39;applies_to&#39;: &#39;node_table&#39;, &#39;n&#39;: &#39;name&#39;},
                            {&#39;applies_to&#39;: &#39;node_table&#39;, &#39;n&#39;: &#39;raw_expression&#39;},
                            {&#39;applies_to&#39;: &#39;edge_table&#39;, &#39;n&#39;: &#39;name&#39;},
                            {&#39;applies_to&#39;: &#39;edge_table&#39;, &#39;n&#39;: &#39;bond_type&#39;},
                            {&#39;applies_to&#39;: &#39;edge_table&#39;, &#39;n&#39;: &#39;s_agent_type&#39;},
                            {&#39;applies_to&#39;: &#39;edge_table&#39;, &#39;n&#39;: &#39;t_agent_type&#39;},
                            {&#39;applies_to&#39;: &#39;edge_table&#39;, &#39;n&#39;: &#39;s_port_name&#39;},
                            {&#39;applies_to&#39;: &#39;edge_table&#39;, &#39;n&#39;: &#39;t_port_name&#39;},
                            {&#39;applies_to&#39;: &#39;edge_table&#39;, &#39;n&#39;: &#39;ident_in_snap&#39;},
                            {&#39;applies_to&#39;: &#39;network_table&#39;, &#39;n&#39;: &#39;name&#39;}]
        # build cytoscape metadata structure
        cx_metadata = [{&#39;name&#39;: &#39;nodes&#39;, &#39;version&#39;: &#39;1.0&#39;},
                       {&#39;name&#39;: &#39;nodeAttributes&#39;, &#39;version&#39;: &#39;1.0&#39;},
                       {&#39;name&#39;: &#39;edges&#39;, &#39;version&#39;: &#39;1.0&#39;},
                       {&#39;name&#39;: &#39;edgeAttributes&#39;, &#39;version&#39;: &#39;1.0&#39;},
                       {&#39;name&#39;: &#39;cyTablecolumn&#39;, &#39;version&#39;: &#39;1.0&#39;},
                       {&#39;name&#39;: &#39;networkAttributes&#39;, &#39;version&#39;: &#39;1.0&#39;}]
        # build cytoscape status structure; unclear why it is needed
        cx_status = [{&#39;error&#39;: &#39;&#39;, &#39;success&#39;: True}]
        # pack and return
        cx_data = [
            {&#39;metaData&#39;: cx_metadata},
            {&#39;cyTableColumn&#39;: cx_table_columns},
            {&#39;nodes&#39;: cx_nodes},
            {&#39;edges&#39;: cx_edges},
            {&#39;nodeAttributes&#39;: cx_node_attributes},
            {&#39;edgeAttributes&#39;: cx_edge_attributes},
            {&#39;status&#39;: cx_status}
        ]
        return cx_data

    def _kappa_to_graphml(self, node_coloring: Optional[Dict[KappaAgent, any]] = None) -&gt; ET.ElementTree:
        &#34;&#34;&#34;Builds the a GraphML representation, ultimately exported as an XML file.
         This method relies on `self.to_netowrkx()`, which is realized for KappaSnapshot
         and KappaComplex objects.
         Optional argument `node_coloring` colorizes by single-agent patterns.&#34;&#34;&#34;
        
        def _colorize_for_node(node_kappa) -&gt; str:
            &#34;&#34;&#34;Deal with agent color: ideally one, possibly multiple, maybe none&#34;&#34;&#34;
            if node_coloring is not None:
                match_colors = [k_col for k_exp, k_col in node_coloring.items() if k_exp in node_kappa]
                if len(match_colors) &gt; 0:
                    chosen_color = match_colors[0]
                    if isinstance(chosen_color, str):
                        return chosen_color
                    elif mpco.is_color_like(chosen_color):
                        return mpco.to_hex(chosen_color)
                    else:
                        Warning(&#34;I don&#39;t know how to serialize type {} of {}, returning empty string&#34;.format(type(chosen_color), chosen_color))
                        return &#39;&#39;

        graphml_root = ET.Element(&#39;graphml&#39;, attrib={
            &#39;xmlns&#39;: &#34;http://graphml.graphdrawing.org/xmlns&#34;,
            &#39;xmlns:xsi&#39;: &#34;http://www.w3.org/2001/XMLSchema-instance&#34;,
            &#39;xsi:schemaLocation&#39;: &#34;http://graphml.graphdrawing.org/xmlns &#34; +
            &#34;http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd&#34;})
        tree = ET.ElementTree(graphml_root)

        # define &amp; add attributes for typing &amp; naming &amp; identifying agents &amp; bonds
        data_keys = [
            (&#39;node&#39;, &#39;AgentType&#39;, &#39;string&#39;),
            (&#39;node&#39;, &#39;AgentExpression&#39;, &#39;string&#39;),
            (&#39;node&#39;, &#39;AgentIdentifier&#39;, &#39;int&#39;),
            (&#39;node&#39;, &#39;NodeColor&#39;, &#39;string&#39;),
            (&#39;edge&#39;, &#39;BondType&#39;, &#39;string&#39;),
            (&#39;edge&#39;, &#39;LocalIdentifier&#39;, &#39;int&#39;)
        ]
        for key_domain, key_id, key_type in data_keys:
            tree.getroot().append(ET.Element(&#39;key&#39;, attrib={
                &#39;for&#39;: key_domain, &#39;id&#39;: key_id, &#39;attr.name&#39;: key_id, &#39;attr.type&#39;: key_type
            }))

        this_net = self.to_networkx()
        max_degree = len(nx.degree_histogram(this_net))

        # define &amp; add graph sub-tree, with meta-data for efficient parsing
        tree.getroot().append(ET.Element(&#39;graph&#39;, attrib={
            &#39;id&#39;: &#39;G&#39;,
            &#39;edgedefault&#39;: &#39;undirected&#39;,
            &#39;parse.nodeids&#39;: &#39;canonical&#39;,
            &#39;parse.edgeids&#39;: &#39;canonical&#39;,
            &#39;parse.order&#39;: &#39;nodesfirst&#39;,
            &#39;parse.maxindegree&#39;: str(max_degree),
            &#39;parse.maxoutdegree&#39;: str(max_degree),
            &#39;parse.nodes&#39;: str(this_net.order()),
            &#39;parse.edges&#39;: str(this_net.size(weight=None))
        }))
        graph_root = tree.find(&#39;./graph&#39;)

        # node iteration
        for n_id, n_data in this_net.nodes.items():
            n_degree = this_net.degree(n_id)
            new_node = ET.Element(&#39;node&#39;, attrib={&#39;id&#39;: &#39;n{}&#39;.format(n_id), &#39;parse.indegree&#39;: str(n_degree), &#39;parse.outdegree&#39;: str(n_degree)})
            
            # metadata for nodes
            node_meta = [
                (&#39;desc&#39;, None, n_data[&#39;kappa&#39;]),
                (&#39;data&#39;, &#39;AgentType&#39;, n_data[&#39;kappa&#39;].get_agent_name()),
                (&#39;data&#39;, &#39;AgentExpression&#39;, n_data[&#39;kappa&#39;]),
                (&#39;data&#39;, &#39;AgentIdentifier&#39;, n_id),
                (&#39;data&#39;, &#39;NodeColor&#39;, _colorize_for_node(n_data[&#39;kappa&#39;]))
            ]
            for n_class, key_name, payload in node_meta:
                node_annot = ET.Element(n_class) if key_name is None else ET.Element(n_class, attrib={&#39;key&#39;: key_name})
                node_annot.text = str(payload)
                new_node.append(node_annot)
            graph_root.append(new_node)

            # generate ports from KappaPorts
            for some_ix, some_site in enumerate(n_data[&#39;kappa&#39;].get_agent_ports()):
                # type NMTOKEN is more constrained than Kappa&#39;s Unicode,
                # so the &#34;name&#34;, which serves as an identifier, is just the index in the agent&#39;s signature
                new_port = ET.Element(&#39;port&#39;, attrib={&#39;name&#39;: str(some_ix)})
                port_desc = ET.SubElement(new_port, &#39;desc&#39;)
                port_desc.text = str(some_site)
                new_node.append(new_port)
        
        # edge iteration
        edge_counter = 0    # non-id&#39;d graphs do not have global edge identifiers
        for e_source, e_target, e_data in this_net.edges(data=True):
            port_ix_source = this_net.nodes[e_source][&#39;kappa&#39;].get_agent_ports().index(this_net.nodes[e_source][&#39;kappa&#39;].get_port(e_data[&#39;bond type&#39;].site_one))
            port_ix_target = this_net.nodes[e_target][&#39;kappa&#39;].get_agent_ports().index(this_net.nodes[e_target][&#39;kappa&#39;].get_port(e_data[&#39;bond type&#39;].site_two))
            new_edge = ET.Element(&#39;edge&#39;, attrib={
                &#39;id&#39;: &#39;edge{}&#39;.format(edge_counter),
                &#39;directed&#39;: &#39;false&#39;,
                &#39;source&#39;: &#39;n{}&#39;.format(e_source),
                &#39;target&#39;: &#39;n{}&#39;.format(e_target),
                &#39;sourceport&#39;: str(port_ix_source),
                &#39;targetport&#39;: str(port_ix_target)
            })
            graph_root.append(new_edge)
            # metadata for edges
            edge_meta = [
                (&#39;BondType&#39;, e_data[&#39;bond type&#39;]),
                (&#39;LocalIdentifier&#39;, e_data[&#39;bond id&#39;])
            ]
            for key_name, payload in edge_meta:
                edge_annot = ET.Element(&#39;data&#39;, attrib={&#39;key&#39;: key_name})
                edge_annot.text = str(payload)
                new_edge.append(edge_annot)
            edge_counter += 1
        return tree</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="KaSaAn.core.KappaMultiAgentGraph.KappaMultiAgentGraph"><code class="flex name class">
<span>class <span class="ident">KappaMultiAgentGraph</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class containing common components to <code>KappaComplex</code> and <code>KappaSnapshot</code>, its subclasses.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KappaMultiAgentGraph(KappaEntity):
    &#34;&#34;&#34;Abstract class containing common components to `KappaComplex` and `KappaSnapshot`, its subclasses.&#34;&#34;&#34;

    @abstractmethod
    def __init__(self):
        pass

    @abstractmethod
    def to_networkx(self) -&gt; nx.MultiGraph:
        &#34;&#34;&#34;Abstract method included as place-holder for typing reasons.&#34;&#34;&#34;
        pass

    def _kappa_to_cytoscape_cx(self) -&gt; List[Dict]:
        &#34;&#34;&#34;
        Given a kappa graph (i.e. KappaComplex or KappaSnapshot), produce a Python structure
         that can be JSON encoded to produce a Cytoscape-compatible CX file.
        &#34;&#34;&#34;
        kappa_net = self.to_networkx()
        # construct &#34;node&#34; and &#34;nodeAttributes&#34; structures
        cx_nodes = []
        cx_node_attributes = []
        for node_ident, node_data in kappa_net.nodes.data():
            cx_node = {&#39;@id&#39;: node_ident,
                       &#39;n&#39;: node_data[&#39;kappa&#39;].get_agent_name()}
            cx_node_attribute = {&#39;po&#39;: node_ident,
                                 &#39;n&#39;: &#39;raw_expression&#39;,
                                 &#39;v&#39;: str(node_data[&#39;kappa&#39;])}
            cx_nodes.append(cx_node)
            cx_node_attributes.append(cx_node_attribute)
        # cytoscape expects edges to have identifiers; these exist in the same space as the nodes;
        # I preserve node identifiers, and start a counter from those to then identify edges
        edge_ident = 0 + kappa_net.number_of_nodes()
        cx_edges = []
        cx_edge_attributes = []
        for e_source, e_target, e_data in kappa_net.edges.data():
            # find the port names
            port_names = []
            e_source_kappa = kappa_net.nodes.data()[e_source][&#39;kappa&#39;]
            e_target_kappa = kappa_net.nodes.data()[e_target][&#39;kappa&#39;]
            bond_type: KappaBond = e_data[&#39;bond type&#39;]
            for this_agent in [e_source_kappa, e_target_kappa]:
                for this_site in this_agent.get_agent_signature():
                    # is this site a port, or a counter?
                    if this_site.get_port_bond_state():
                        if e_data[&#39;bond id&#39;] == this_site.get_port_bond_state():
                            port_names.append(this_site.get_port_name())
            # build edge dictionary list
            cx_edge = {&#39;s&#39;: e_source,
                       &#39;t&#39;: e_target,
                       &#39;@id&#39;: edge_ident}
            cx_edge_attribute = [{&#39;po&#39;: edge_ident,
                                  &#39;n&#39;: &#39;bond_type&#39;,
                                  &#39;v&#39;: str(bond_type)},
                                 {&#39;po&#39;: edge_ident,
                                  &#39;n&#39;: &#39;s_agent_type&#39;,
                                  &#39;v&#39;: e_source_kappa.get_agent_name()},
                                 {&#39;po&#39;: edge_ident,
                                  &#39;n&#39;: &#39;t_agent_type&#39;,
                                  &#39;v&#39;: e_target_kappa.get_agent_name()},
                                 {&#39;po&#39;: edge_ident,
                                  &#39;n&#39;: &#39;s_port_name&#39;,
                                  &#39;v&#39;: port_names[0]},
                                 {&#39;po&#39;: edge_ident,
                                  &#39;n&#39;: &#39;t_port_name&#39;,
                                  &#39;v&#39;: port_names[1]},
                                 {&#39;po&#39;: edge_ident,
                                  &#39;n&#39;: &#39;ident_in_snap&#39;,
                                  &#39;v&#39;: e_data[&#39;bond id&#39;]}]
            cx_edges.append(cx_edge)
            cx_edge_attributes.extend(cx_edge_attribute)
            edge_ident += 1
        # build cytoscape table structure
        cx_table_columns = [{&#39;applies_to&#39;: &#39;node_table&#39;, &#39;n&#39;: &#39;name&#39;},
                            {&#39;applies_to&#39;: &#39;node_table&#39;, &#39;n&#39;: &#39;raw_expression&#39;},
                            {&#39;applies_to&#39;: &#39;edge_table&#39;, &#39;n&#39;: &#39;name&#39;},
                            {&#39;applies_to&#39;: &#39;edge_table&#39;, &#39;n&#39;: &#39;bond_type&#39;},
                            {&#39;applies_to&#39;: &#39;edge_table&#39;, &#39;n&#39;: &#39;s_agent_type&#39;},
                            {&#39;applies_to&#39;: &#39;edge_table&#39;, &#39;n&#39;: &#39;t_agent_type&#39;},
                            {&#39;applies_to&#39;: &#39;edge_table&#39;, &#39;n&#39;: &#39;s_port_name&#39;},
                            {&#39;applies_to&#39;: &#39;edge_table&#39;, &#39;n&#39;: &#39;t_port_name&#39;},
                            {&#39;applies_to&#39;: &#39;edge_table&#39;, &#39;n&#39;: &#39;ident_in_snap&#39;},
                            {&#39;applies_to&#39;: &#39;network_table&#39;, &#39;n&#39;: &#39;name&#39;}]
        # build cytoscape metadata structure
        cx_metadata = [{&#39;name&#39;: &#39;nodes&#39;, &#39;version&#39;: &#39;1.0&#39;},
                       {&#39;name&#39;: &#39;nodeAttributes&#39;, &#39;version&#39;: &#39;1.0&#39;},
                       {&#39;name&#39;: &#39;edges&#39;, &#39;version&#39;: &#39;1.0&#39;},
                       {&#39;name&#39;: &#39;edgeAttributes&#39;, &#39;version&#39;: &#39;1.0&#39;},
                       {&#39;name&#39;: &#39;cyTablecolumn&#39;, &#39;version&#39;: &#39;1.0&#39;},
                       {&#39;name&#39;: &#39;networkAttributes&#39;, &#39;version&#39;: &#39;1.0&#39;}]
        # build cytoscape status structure; unclear why it is needed
        cx_status = [{&#39;error&#39;: &#39;&#39;, &#39;success&#39;: True}]
        # pack and return
        cx_data = [
            {&#39;metaData&#39;: cx_metadata},
            {&#39;cyTableColumn&#39;: cx_table_columns},
            {&#39;nodes&#39;: cx_nodes},
            {&#39;edges&#39;: cx_edges},
            {&#39;nodeAttributes&#39;: cx_node_attributes},
            {&#39;edgeAttributes&#39;: cx_edge_attributes},
            {&#39;status&#39;: cx_status}
        ]
        return cx_data

    def _kappa_to_graphml(self, node_coloring: Optional[Dict[KappaAgent, any]] = None) -&gt; ET.ElementTree:
        &#34;&#34;&#34;Builds the a GraphML representation, ultimately exported as an XML file.
         This method relies on `self.to_netowrkx()`, which is realized for KappaSnapshot
         and KappaComplex objects.
         Optional argument `node_coloring` colorizes by single-agent patterns.&#34;&#34;&#34;
        
        def _colorize_for_node(node_kappa) -&gt; str:
            &#34;&#34;&#34;Deal with agent color: ideally one, possibly multiple, maybe none&#34;&#34;&#34;
            if node_coloring is not None:
                match_colors = [k_col for k_exp, k_col in node_coloring.items() if k_exp in node_kappa]
                if len(match_colors) &gt; 0:
                    chosen_color = match_colors[0]
                    if isinstance(chosen_color, str):
                        return chosen_color
                    elif mpco.is_color_like(chosen_color):
                        return mpco.to_hex(chosen_color)
                    else:
                        Warning(&#34;I don&#39;t know how to serialize type {} of {}, returning empty string&#34;.format(type(chosen_color), chosen_color))
                        return &#39;&#39;

        graphml_root = ET.Element(&#39;graphml&#39;, attrib={
            &#39;xmlns&#39;: &#34;http://graphml.graphdrawing.org/xmlns&#34;,
            &#39;xmlns:xsi&#39;: &#34;http://www.w3.org/2001/XMLSchema-instance&#34;,
            &#39;xsi:schemaLocation&#39;: &#34;http://graphml.graphdrawing.org/xmlns &#34; +
            &#34;http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd&#34;})
        tree = ET.ElementTree(graphml_root)

        # define &amp; add attributes for typing &amp; naming &amp; identifying agents &amp; bonds
        data_keys = [
            (&#39;node&#39;, &#39;AgentType&#39;, &#39;string&#39;),
            (&#39;node&#39;, &#39;AgentExpression&#39;, &#39;string&#39;),
            (&#39;node&#39;, &#39;AgentIdentifier&#39;, &#39;int&#39;),
            (&#39;node&#39;, &#39;NodeColor&#39;, &#39;string&#39;),
            (&#39;edge&#39;, &#39;BondType&#39;, &#39;string&#39;),
            (&#39;edge&#39;, &#39;LocalIdentifier&#39;, &#39;int&#39;)
        ]
        for key_domain, key_id, key_type in data_keys:
            tree.getroot().append(ET.Element(&#39;key&#39;, attrib={
                &#39;for&#39;: key_domain, &#39;id&#39;: key_id, &#39;attr.name&#39;: key_id, &#39;attr.type&#39;: key_type
            }))

        this_net = self.to_networkx()
        max_degree = len(nx.degree_histogram(this_net))

        # define &amp; add graph sub-tree, with meta-data for efficient parsing
        tree.getroot().append(ET.Element(&#39;graph&#39;, attrib={
            &#39;id&#39;: &#39;G&#39;,
            &#39;edgedefault&#39;: &#39;undirected&#39;,
            &#39;parse.nodeids&#39;: &#39;canonical&#39;,
            &#39;parse.edgeids&#39;: &#39;canonical&#39;,
            &#39;parse.order&#39;: &#39;nodesfirst&#39;,
            &#39;parse.maxindegree&#39;: str(max_degree),
            &#39;parse.maxoutdegree&#39;: str(max_degree),
            &#39;parse.nodes&#39;: str(this_net.order()),
            &#39;parse.edges&#39;: str(this_net.size(weight=None))
        }))
        graph_root = tree.find(&#39;./graph&#39;)

        # node iteration
        for n_id, n_data in this_net.nodes.items():
            n_degree = this_net.degree(n_id)
            new_node = ET.Element(&#39;node&#39;, attrib={&#39;id&#39;: &#39;n{}&#39;.format(n_id), &#39;parse.indegree&#39;: str(n_degree), &#39;parse.outdegree&#39;: str(n_degree)})
            
            # metadata for nodes
            node_meta = [
                (&#39;desc&#39;, None, n_data[&#39;kappa&#39;]),
                (&#39;data&#39;, &#39;AgentType&#39;, n_data[&#39;kappa&#39;].get_agent_name()),
                (&#39;data&#39;, &#39;AgentExpression&#39;, n_data[&#39;kappa&#39;]),
                (&#39;data&#39;, &#39;AgentIdentifier&#39;, n_id),
                (&#39;data&#39;, &#39;NodeColor&#39;, _colorize_for_node(n_data[&#39;kappa&#39;]))
            ]
            for n_class, key_name, payload in node_meta:
                node_annot = ET.Element(n_class) if key_name is None else ET.Element(n_class, attrib={&#39;key&#39;: key_name})
                node_annot.text = str(payload)
                new_node.append(node_annot)
            graph_root.append(new_node)

            # generate ports from KappaPorts
            for some_ix, some_site in enumerate(n_data[&#39;kappa&#39;].get_agent_ports()):
                # type NMTOKEN is more constrained than Kappa&#39;s Unicode,
                # so the &#34;name&#34;, which serves as an identifier, is just the index in the agent&#39;s signature
                new_port = ET.Element(&#39;port&#39;, attrib={&#39;name&#39;: str(some_ix)})
                port_desc = ET.SubElement(new_port, &#39;desc&#39;)
                port_desc.text = str(some_site)
                new_node.append(new_port)
        
        # edge iteration
        edge_counter = 0    # non-id&#39;d graphs do not have global edge identifiers
        for e_source, e_target, e_data in this_net.edges(data=True):
            port_ix_source = this_net.nodes[e_source][&#39;kappa&#39;].get_agent_ports().index(this_net.nodes[e_source][&#39;kappa&#39;].get_port(e_data[&#39;bond type&#39;].site_one))
            port_ix_target = this_net.nodes[e_target][&#39;kappa&#39;].get_agent_ports().index(this_net.nodes[e_target][&#39;kappa&#39;].get_port(e_data[&#39;bond type&#39;].site_two))
            new_edge = ET.Element(&#39;edge&#39;, attrib={
                &#39;id&#39;: &#39;edge{}&#39;.format(edge_counter),
                &#39;directed&#39;: &#39;false&#39;,
                &#39;source&#39;: &#39;n{}&#39;.format(e_source),
                &#39;target&#39;: &#39;n{}&#39;.format(e_target),
                &#39;sourceport&#39;: str(port_ix_source),
                &#39;targetport&#39;: str(port_ix_target)
            })
            graph_root.append(new_edge)
            # metadata for edges
            edge_meta = [
                (&#39;BondType&#39;, e_data[&#39;bond type&#39;]),
                (&#39;LocalIdentifier&#39;, e_data[&#39;bond id&#39;])
            ]
            for key_name, payload in edge_meta:
                edge_annot = ET.Element(&#39;data&#39;, attrib={&#39;key&#39;: key_name})
                edge_annot.text = str(payload)
                new_edge.append(edge_annot)
            edge_counter += 1
        return tree</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="KaSaAn.core.KappaEntity.KappaEntity" href="KappaEntity.html#KaSaAn.core.KappaEntity.KappaEntity">KappaEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>KaSaAn.core.KappaComplex.KappaComplex</li>
<li>KaSaAn.core.KappaSnapshot.KappaSnapshot</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="KaSaAn.core.KappaMultiAgentGraph.KappaMultiAgentGraph.to_networkx"><code class="name flex">
<span>def <span class="ident">to_networkx</span></span>(<span>self) ‑> networkx.classes.multigraph.MultiGraph</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract method included as place-holder for typing reasons.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_networkx(self) -&gt; nx.MultiGraph:
    &#34;&#34;&#34;Abstract method included as place-holder for typing reasons.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="KaSaAn.core" href="index.html">KaSaAn.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="KaSaAn.core.KappaMultiAgentGraph.KappaMultiAgentGraph" href="#KaSaAn.core.KappaMultiAgentGraph.KappaMultiAgentGraph">KappaMultiAgentGraph</a></code></h4>
<ul class="">
<li><code><a title="KaSaAn.core.KappaMultiAgentGraph.KappaMultiAgentGraph.to_networkx" href="#KaSaAn.core.KappaMultiAgentGraph.KappaMultiAgentGraph.to_networkx">to_networkx</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>